#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int screenHeight = 127;
const int screenWidth  = 177;
const int numOfRows = 4;
const int numOfCols = 6;
const int size = (numOfCols*numOfRows)*3;

int robHeading = 0; // 0=North, 1=East, 2=South, 3=West
int robRow = 0;	//Starting Row
int robCol = 0;	//Starting Column
const int targetRow = 4;	//Target Row
const int targetCol = 6;	//Target Column

int goFwdArray[size];	// Keeps Track of Moves
int goBwdArray[size];	// Reverses and Alters Moves to remove BackTracks
int counter = 0;    // Used to count through arrays
int alignLogic = 0; // Used to count step too re-align
typedef struct{
	int nWall;  // 0 = door, 1 = wall
	int eWall;
	int sWall;
	int wWall;
}cell;

//Initialize Maze
cell Maze[numOfRows][numOfCols];

//Declare all functions
void buildOuterBorders();
void gridDraw();
void drawBot();
void turnRight();
void turnLeft();
void goFwd();
void shortestPathAlgo();
void headback();
void refreshScreen();
void bin();
bool wallAhead();
void setFwd();
void hitWall();

task main(){

	setFwd();
	datalogClear();
	buildOuterBorders();
	refreshScreen();
	//Do Right Wall Algorithm Until End Reached
	while ((robCol != targetCol-1)||(robRow != targetRow-1))
	{
		bin();
	}

	refreshScreen();
	displayCenteredTextLine(3,"We Reached the Target!");
	wait1Msec(2000);
	refreshScreen();

	// Calculate Shortest Path Back
	shortestPathAlgo();
	// Travel Back Shortest Path
	headback();

	displayCenteredTextLine(3,"We Reached Back Home!");
	wait1Msec(2000);

}


bool wallAhead()
{	//Distance Of Wall Ahead
	if (getUSDistance(sonarSensor) > 15)
	{
		return(false);
	}
	return(true);
}

//Re-Alignment With Walls
void hitWall()
{
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,300,50);
	setMotorTarget(rightMotor,300,50);
	waitUntilMotorStop(leftMotor);
	sleep(500);
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor,-90,16);
	setMotorTarget(rightMotor,-90,16);
	waitUntilMotorStop(leftMotor);
	sleep(500);
}

// Right Wall Algorithm
void bin()
{
	turnRight();
	alignLogic ++;
	refreshScreen();
	while (wallAhead() == true)
	{
		if (alignLogic > 4)
		{ 
		hitWall(); 
		alignLogic = 0;
		}
				
		if (robHeading == 0)
		{
			Maze[robRow][robCol].nWall = 1;
			refreshScreen();
		}
		else if (robHeading == 1)
		{
			Maze[robRow][robCol].eWall = 1;
			refreshScreen();
		}
		else if (robHeading == 2)
		{
			Maze[robRow][robCol].sWall = 1;
			refreshScreen();
		}
		else if (robHeading == 3)
		{
			Maze[robRow][robCol].wWall = 1;
			refreshScreen();
		}

		turnLeft();
		alignLogic ++;
		refreshScreen();
	}
	goFwd();
	alignLogic ++;
	refreshScreen();
}



void refreshScreen(){
	eraseDisplay();
	gridDraw();
	drawBot();
}

void setFwd()
{
	for(int i=0;i<size;i++)
	{
		goFwdArray[i] = 9;
		goBwdArray[i] = 9;
	}
}

void goFwd(){
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	//733/360 ~ 33.2/2*pi*r(2.8)
	// This Function is used to maintain straight driving
	while(getMotorEncoder(leftMotor)< 733)
	{
		if (getMotorEncoder(leftMotor)-getMotorEncoder(rightMotor)>0)
		{
			setMotorSpeed(leftMotor,36);
			setMotorSpeed(rightMotor,40);
		}
		else if (getMotorEncoder(leftMotor)-getMotorEncoder(rightMotor)<0)
		{
			setMotorSpeed(leftMotor,40);
			setMotorSpeed(rightMotor,36);
		}
		else{
			setMotorSpeed(leftMotor,40);
			setMotorSpeed(rightMotor,40);
		}
	}
	setMotorSpeed(leftMotor,00);
	setMotorSpeed(rightMotor,00);
	sleep(500);

	wait1Msec(1000);  // waste some time to simulate motion

	if (robHeading==0)	{   // Going Fwd North
		robRow++;
		goFwdArray[counter]=0;
		counter++;
	}
	else if (robHeading==1)	{   // Going Fwd East
		robCol++;
		goFwdArray[counter]=1;
		counter++;
	}
	else if (robHeading==2)	{   // Going Fwd South
		robRow--;
		goFwdArray[counter]=2;
		counter++;
	}
	else if (robHeading==3)	{   // Going Fwd West
		robCol--;
		goFwdArray[counter]=3;
		counter++;
	}
	else {
		robRow = 9;
		robCol = 9;
	}
}
void shortestPathAlgo()
{
	//Changing the goFwd Array Values to their opposites
	//also reverses it

	for(int i=0;i<size;i++)
	{
		if(goFwdArray[i]==0)
		{
			goBwdArray[i]=2;
		}
		else if(goFwdArray[i]==1)
		{
			goBwdArray[i]=3;
		}
		else if(goFwdArray[i]==2)
		{
			goBwdArray[i]=0;
		}
		else if(goFwdArray[i]==3)
		{
			goBwdArray[i]=1;
		}
		else
			goBwdArray[i]=9;
	}

		//for (int i=0;i<size;i++)
		//{
		//datalogDataGroupStart();
		//datalogAddValue(0,cc);
		//datalogDataGroupEnd();
		//}


	// Now I am going to check whenever there is a backtrack I will make those numbers = 9

	int cc = 1;
	int strt = 0;
	int fin = 0 ;
	int j = 0;
	int logic = 0;

	while(cc != size - 2)
		{
		if (logic == 0)
			{
			strt = goBwdArray[j];

			if (strt != 9)
			{	logic = 1;
				cc = j+1;}

			if (strt == 9)
				{
					j++;
				}
			}

		if (logic == 1)
			{
			fin = goBwdArray[cc];
			if (fin != 9)
			{	logic = 2; }

			if (fin == 9)
				{
					cc++;
				}
			}

		if (logic == 2)
			{
				strt = goBwdArray[j];
				fin = goBwdArray[cc];

				if(abs(strt-fin)==2)
					{
					goBwdArray[j]=9;
					goBwdArray[cc] = 9;
					j = 0;
					cc = 1;
					logic = 0;
					}
				else
					{
					j++;
					cc = (j + 1);
					logic = 0;
					}
				}
			}
		}

void headback(){
	int turnError = 0;

	for (int i=size; i>0; i--)
	{

		turnError = robHeading - goBwdArray[i-1];
		if (turnError == 3)
		{
			turnRight();
			refreshScreen();
			goFwd();
			refreshScreen();
		}
		if (turnError == -3)
		{
			turnLeft();
			refreshScreen();
			goFwd();
			refreshScreen();
		}
		if (turnError == 0)
		{
			goFwd();
			refreshScreen();
		}
		if (turnError == -1)
		{
			turnRight();
			refreshScreen();
			goFwd();
			refreshScreen();
		}
		if (abs(turnError) == 2)
		{
			turnRight();
			refreshScreen();
			turnRight();
			refreshScreen();
			goFwd();
			refreshScreen();
		}
		if (turnError == 1)
		{
			turnLeft();
			refreshScreen();
			goFwd();
			refreshScreen();
		}

		if (goBwdArray[i-1] != 9)
		{
			if (wallAhead() == true)
			{
				hitWall();
			}
		}
	}
}


void turnRight(){

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	if (robHeading < 3)
	{
		robHeading++;
	}
	else robHeading=0;

	resetGyro(gyroSensor);
	//turn till you reach degrees

	while(getGyroDegrees(gyroSensor) < 89)
	{
		if (getMotorEncoder(rightMotor) > getMotorEncoder(leftMotor))
		{
			setMotorSpeed(rightMotor,-16);
			setMotorSpeed(leftMotor,18);
		}
		if (getMotorEncoder(rightMotor) < getMotorEncoder(leftMotor))
		{
			setMotorSpeed(rightMotor,-18);
			setMotorSpeed(leftMotor,16);
		}
		else
		{
			setMotorSpeed(rightMotor,-16);
			setMotorSpeed(leftMotor,16);
		}
	}

	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
	sleep(1000);

}


void turnLeft(){

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	if (robHeading != 0)
	{
		robHeading--;
	}
	else robHeading=3;

	resetGyro(gyroSensor);
	//turn till you reach degrees
	while(getGyroDegrees(gyroSensor) > -89)
	{
		if ((getMotorEncoder(leftMotor)+getMotorEncoder(rightMotor))>0)
		{
			setMotorSpeed(leftMotor,-16);
			setMotorSpeed(rightMotor,17);
		}
		if (getMotorEncoder(leftMotor)+getMotorEncoder(rightMotor)<0)
		{
			setMotorSpeed(leftMotor,-17);
			setMotorSpeed(rightMotor,16);
		}
		else
		{
			setMotorSpeed(leftMotor,-16);
			setMotorSpeed(rightMotor,16);
		}
	}



	setMotorSpeed(leftMotor,0);
	setMotorSpeed(rightMotor,0);
	sleep(1000);

}



void buildOuterBorders(){
	for(int col=0; col<numOfCols; col++){
		Maze[0][col].sWall = 1;
		Maze[numOfRows-1][col].nWall = 1;
	}

	for(int row=0; row<numOfRows; row++){
		Maze[row][0].wWall = 1;
		Maze[row][numOfCols-1].eWall = 1;
	}
}



//=====================================================================
void gridDraw(){
	int XStart=0;
	int YStart=0;
	int XEnd  =0;
	int YEnd  =0;
	for(int i=0;i<numOfRows;i++){
		for(int j=0;j<numOfCols;j++){
			if(Maze[i][j].nWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i+1)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (Maze[i][j].eWall==1){
				XStart=(j+1)*screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if (Maze[i][j].wWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j)*screenWidth/numOfCols;
				YEnd  =(i+1)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
			if(Maze[i][j].sWall==1){
				XStart= j   *screenWidth/numOfCols;
				YStart=(i)*screenHeight/numOfRows;
				XEnd  =(j+1)*screenWidth/numOfCols;
				YEnd  =(i)*screenHeight/numOfRows;
				drawLine(XStart,YStart,XEnd,YEnd);
			}
		}
	}
}

//=====================================================================
void drawBot(){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;

	if(robCol==0){
		RobotXpixelPos=screenWidth/12;
	}
	else{
		RobotXpixelPos=(2*robCol+1)*screenWidth/12;
	}

	if(robRow==0){
		RobotYpixelPos=screenHeight/8;
	}
	else{
		RobotYpixelPos=(2*robRow+1)*screenHeight/8;
	}

	switch(robHeading){
	case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^");	break; // Facing North
	case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">"); break; // Facing East
	case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V"); break; // Facing South
	case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<"); break; // Facing West
	default: break;
	}
}
